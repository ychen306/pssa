#include "LICM.h"
#include "pssa/Inserter.h"
#include "pssa/Lower.h"
#include "pssa/PSSA.h"
#include "llvm/Analysis/AliasAnalysis.h"
#include "llvm/Analysis/LoopInfo.h"
#include "llvm/Analysis/PostDominators.h"
#include "llvm/IR/Dominators.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Transforms/Utils/ValueMapper.h"

using namespace llvm;

static cl::list<std::string> FuncsToSkip("funcs-to-skip", cl::CommaSeparated);

namespace {

// Generalized LICM
class GLICM {
  PredicatedSSA *PSSA;
  AliasAnalysis &AA;
  DenseMap<std::pair<Instruction *, VLoop *>, bool> InstMemo;
  DenseMap<std::pair<const ControlCondition *, VLoop *>, bool> CondMemo;
  std::vector<std::pair<Value *, Value *>> RAUWs;

  DenseSet<Value *> Allocas;

  bool isInvariant(Instruction *, VLoop *);
  bool isInvariant(Value *, VLoop *);
  bool isInvariant(VLoop *, VLoop *);
  bool isInvariant(const ControlCondition *, VLoop *);
  bool isInvalidatedByLoop(MemoryLocation, VLoop *);
  bool requiresReload(MemoryLocation, VLoop *);
  void hoistLoadSpeculatively(LoadInst *LI, VLoop *VL);
  MemoryLocation getLoadLocation(LoadInst *);

public:
  GLICM(PredicatedSSA *PSSA, AliasAnalysis &AA) : PSSA(PSSA), AA(AA) {}
  bool runOnLoop(VLoop *);
  void doRAUW() {
    for (auto [OldV, NewV] : RAUWs)
      OldV->replaceAllUsesWith(NewV);
  }
};

} // namespace

MemoryLocation GLICM::getLoadLocation(LoadInst *LI) {
  const auto &DL = PSSA->getFunction()->getParent()->getDataLayout();

  return MemoryLocation(
      LI->getPointerOperand(),
      LocationSize::precise(DL.getTypeStoreSize(LI->getType())),
      LI->getAAMetadata());
}

bool GLICM::isInvalidatedByLoop(MemoryLocation Loc, VLoop *VL) {
  for (auto &InstOrLoop : VL->items()) {
    if (auto *I = InstOrLoop.asInstruction()) {
      // Don't query AA directly with a load instruction,
      // which could have been generated by us
      if (auto *LI = dyn_cast<LoadInst>(I)) {
        // Be conservative in the face of atomic.
        if (isStrongerThan(LI->getOrdering(), AtomicOrdering::Unordered))
          return true;
        continue;
      }
      if (auto *SI = dyn_cast<StoreInst>(I);
          SI && Allocas.count(SI->getPointerOperand())) {
        if (Loc.Ptr == SI->getPointerOperand())
          return true;
        continue;
      }
      if (isModSet(AA.getModRefInfo(I, Loc)))
        return true;
    } else {
      if (isInvalidatedByLoop(Loc, InstOrLoop.asLoop()))
        return true;
    }
  }
  return false;
}

bool GLICM::requiresReload(MemoryLocation Loc, VLoop *VL) {
  for (auto &InstOrLoop : VL->items()) {
    if (auto *I = InstOrLoop.asInstruction()) {
      if (auto *SI = dyn_cast<StoreInst>(I);
          SI && Allocas.count(SI->getPointerOperand())) {
        continue;
      }
      if (auto *SI = dyn_cast<StoreInst>(I)) {
        const auto &DL = PSSA->getFunction()->getParent()->getDataLayout();

        MemoryLocation Loc2(
            SI->getPointerOperand(),
            LocationSize::precise(DL.getTypeStoreSize(SI->getValueOperand()->getType())),
            SI->getAAMetadata());
        if (AA.alias(Loc, Loc2) && Loc.Size != Loc2.Size) {
          return true;
        }
        continue;
      }
      if (!I->mayWriteToMemory())
        continue;
      if (isModSet(AA.getModRefInfo(I, Loc)))
        return true;
    } else {
      if (isInvalidatedByLoop(Loc, InstOrLoop.asLoop()))
        return true;
    }
  }
  return false;
}

bool GLICM::isInvariant(Value *V, VLoop *VL) {
  auto *I = dyn_cast<Instruction>(V);
  return !I || isInvariant(I, VL);
}

// TODO: deal with memory
// Check is I is invariant w.r.t. VL
bool GLICM::isInvariant(Instruction *I, VLoop *VL) {
  auto It = InstMemo.find({I, VL});
  if (It != InstMemo.end())
    return It->second;

  if (VL->contains(I) && PSSA->getLoopForInst(I) != VL)
    return InstMemo[{I, VL}] = false;

  // For now, just assume Mu nodes are always variant
  auto *PN = dyn_cast<PHINode>(I);
  if (PN && PSSA->getLoopForInst(PN)->isMu(PN))
    return false;

  if (!isa<LoadInst>(I) && I->mayReadOrWriteMemory())
    return false;

  if (auto *LI = dyn_cast<LoadInst>(I)) {
    if (!LI->isSimple())
      return false;
    auto *Ptr = dyn_cast<Instruction>(LI->getPointerOperand());
    if (Ptr && !isInvariant(Ptr, VL))
      return false;
    if (isInvalidatedByLoop(getLoadLocation(LI), VL))
      return false;
  }

  if (!VL->contains(I))
    return true;

  for (auto *O : I->operand_values()) {
    if (auto *OI = dyn_cast<Instruction>(O); OI && !isInvariant(OI, VL))
      return false;
  }

  // For gated phis, also need to check that their conditions are invariant
  if (PN && VL->isGatedPhi(PN)) {
    for (auto *C : VL->getPhiConditions(PN)) {
      if (!isInvariant(C, VL))
        return false;
    }
  }

  // FIXME:
  // this can also be relaxed so we can execute things like ADD speculatively
  return isInvariant(PSSA->getInstCond(I), VL);
}

static void summarize(VLoop *VL, SmallVectorImpl<Instruction *> &LiveIns,
                      SmallVectorImpl<Instruction *> &MemoryAccesses) {
  DenseSet<const ControlCondition *> Processed;
  std::function<void(const ControlCondition *)> ProcessCondition =
      [&](const ControlCondition *C) {
        if (!C)
          return;
        if (!Processed.insert(C).second)
          return;
        if (auto *And = dyn_cast<ConditionAnd>(C)) {
          ProcessCondition(And->Parent);
          auto *I = dyn_cast<Instruction>(And->Cond);
          if (I && !VL->contains(I))
            LiveIns.push_back(I);
          return;
        }
        llvm::for_each(cast<ConditionOr>(C)->Conds, ProcessCondition);
      };

  SmallVector<VLoop *, 8> Worklist{VL};
  while (!Worklist.empty()) {
    auto *VL2 = Worklist.pop_back_val();

    ProcessCondition(VL2->getLoopCond());
    ProcessCondition(VL2->getBackEdgeCond());

    for (auto *PN : VL2->mus()) {
      auto *I = dyn_cast<Instruction>(PN->getOperand(0));
      if (I && !VL->contains(I))
        LiveIns.push_back(I);
    }

    for (auto &InstOrLoop : VL2->items()) {
      if (auto *SubVL = InstOrLoop.asLoop()) {
        Worklist.push_back(SubVL);
        continue;
      }

      auto *I = InstOrLoop.asInstruction();
      assert(I);
      for (auto *O : I->operand_values()) {
        // Ignore mu of VL
        // auto *PN = dyn_cast<PHINode>(O);
        // if (PN && VL->isMu(PN))
        //  continue;
        auto *OI = dyn_cast<Instruction>(O);
        if (OI && !VL->contains(OI))
          LiveIns.push_back(OI);
      }
      ProcessCondition(VL2->getInstCond(I));

      if (auto *PN = dyn_cast<PHINode>(I)) {
        llvm::for_each(VL2->getPhiConditions(PN), ProcessCondition);
      }

      if (I->mayReadOrWriteMemory()) {
        MemoryAccesses.push_back(I);
      }
    }
  }
}

// Check if `VL` can be hoisted out of its parent loop
bool GLICM::isInvariant(VLoop *VL, VLoop *ParentVL) {
  assert(VL->getParent() == ParentVL);

  if (!isInvariant(VL->getLoopCond(), ParentVL))
    return false;

  SmallVector<Instruction *> LiveIns, MemoryAccesses;
  summarize(VL, LiveIns, MemoryAccesses);

  for (auto *I : LiveIns) {
    if (!isInvariant(I, ParentVL))
      return false;
  }

  for (auto *I : MemoryAccesses) {
    auto *LI = dyn_cast<LoadInst>(I);
    if (!LI && I->mayReadOrWriteMemory())
      return false;
    assert(LI);
    if (isInvalidatedByLoop(getLoadLocation(LI), ParentVL))
      return false;
  }

  return true;
}

bool GLICM::isInvariant(const ControlCondition *C, VLoop *VL) {
  // True is invariant
  if (!C)
    return true;

  auto It = CondMemo.find({C, VL});
  if (It != CondMemo.end())
    return It->second;

  bool Invariant = true;
  if (auto *And = dyn_cast<ConditionAnd>(C)) {
    auto *I = dyn_cast<Instruction>(And->Cond);
    if (I && !isInvariant(I, VL))
      Invariant = false;
    else
      Invariant = isInvariant(And->Parent, VL);
  } else {
    auto *Or = cast<ConditionOr>(C);
    for (auto *C2 : Or->Conds) {
      if (!isInvariant(C2, VL)) {
        Invariant = false;
        break;
      }
    }
  }

  return CondMemo[{C, VL}] = Invariant;
}

// We only assume LI is done unconditionally within the loop
void GLICM::hoistLoadSpeculatively(LoadInst *LI, VLoop *VL) {
  errs() << "!!! Hoisting " << *LI << " speculatively\n";
  auto *ParentVL = VL->getParent();
  Inserter InsertBeforeVL(ParentVL, VL->getLoopCond(), PSSA->toIterator(VL));

  auto *Alloca = InsertBeforeVL.make<AllocaInst>(LI->getType(), 0, nullptr, "", 
      PSSA->getFunction()->getEntryBlock().getFirstNonPHI());
  Allocas.insert(Alloca);

  auto *Ty = LI->getType();
  auto *Ptr = LI->getPointerOperand();
  auto Loc = getLoadLocation(LI);

  auto *PreLoad =
      InsertBeforeVL.make<LoadInst>(Ty, Ptr, LI->getName() + ".preload",
                                    false /*is volatile*/, LI->getAlign());
  InsertBeforeVL.make<StoreInst>(PreLoad, Alloca, false, LI->getAlign());

  auto *Mu = VL->createMu(PreLoad);
  // The value we are replacing the load with
  Value *LoadVal = Mu;

  SmallVector<Item> Items;
  // Collect the instructions first to avoid invalidating iterator
  DenseSet<Item, ItemHashInfo> InvalidatingItems;
  for (auto &InstOrLoop : VL->items()) {
    Items.push_back(InstOrLoop);
    if (auto *I = InstOrLoop.asInstruction()) {
      if (auto *SI = dyn_cast<StoreInst>(I);
          SI && Allocas.count(SI->getPointerOperand())) {
        if (Loc.Ptr == SI->getPointerOperand())
          InvalidatingItems.insert(I);
        continue;
      }
      if (I->mayWriteToMemory() && isModSet(AA.getModRefInfo(I, Loc)))
        InvalidatingItems.insert(I);
      continue;
    }

    auto *SubVL = InstOrLoop.asLoop();
    assert(SubVL);
    if (isInvalidatedByLoop(Loc, SubVL))
      InvalidatingItems.insert(InstOrLoop);
  }
  for (auto &InstOrLoop : Items) {
    if (auto *I = InstOrLoop.asInstruction()) {
      if (auto *LI2 = dyn_cast<LoadInst>(I);
          LI2 && LI2->getPointerOperand() == Ptr && LI2->getType() == Ty) {
        // Replace later so that we don't break alias analysis!
        Inserter InsertAfter(VL, VL->getInstCond(I), std::next(VL->toIterator(I)));
        Value *Reload = InsertAfter.make<LoadInst>(Ty, Alloca, "", false, LI->getAlign());
        LoadVal = Reload;
        RAUWs.emplace_back(LI2, LoadVal);
      }
    }

    if (!InvalidatingItems.count(InstOrLoop))
      continue;

    // If it's a store, just forward conditionally
    if (auto *Store = dyn_cast_or_null<StoreInst>(InstOrLoop.asInstruction());
        Store && Store->getValueOperand()->getType() == Ty) {
      // If we know the pointer that could be invalidated, just check the
      // pointer
      auto *StoreC = VL->getInstCond(Store);
      Inserter InsertAfter(VL, StoreC, std::next(VL->toIterator(Store)));
      auto *Eq = cast<Instruction>(
          InsertAfter.create<CmpInst>(Instruction::ICmp, CmpInst::ICMP_EQ,
                                      Store->getPointerOperand(), Ptr));
      Inserter InsertAfterEq(VL, 
          PSSA->getAnd(StoreC, Eq, true /*is true*/),
          std::next(VL->toIterator(Eq)));
      InsertAfterEq.make<StoreInst>(Store->getValueOperand(), Alloca, false, LI->getAlign());
      //Inserter InsertAfterEq(VL, nullptr /*true*/,
      //                       std::next(VL->toIterator(Eq)));
      //LoadVal = InsertAfterEq.createOneHotPhi(
      //    PSSA->getAnd(StoreC, Eq,
      //                 true /*is true*/), /* update the load if load happens and
      //                                       the pointers are equal */
      //    Store->getValueOperand(),       /* if true: forward the store */
      //    LoadVal /* if false: keep the cached value */);
      //LoadVal->setName(LI->getName()+".forward");
      errs() << "Forwarding conditionally\n";
      continue;
    }

    // Just reload for other instructions
    auto *I = InstOrLoop.asInstruction();
    auto *C = I ? VL->getInstCond(I) : InstOrLoop.asLoop()->getLoopCond();
    Inserter InsertAfter(VL, C, std::next(VL->toIterator(InstOrLoop)));
    auto *Reload = cast<Instruction>(
        InsertAfter.make<LoadInst>(Ty, Ptr, LI->getName() + ".reload",
                                   false /*is volatile*/, LI->getAlign()));
    InsertAfter.make<StoreInst>(Reload, Alloca, false, LI->getAlign());
    //Inserter InsertAfterReload(VL, nullptr /* true */,
    //                           std::next(VL->toIterator(Reload)));
    //LoadVal = InsertAfterReload.createOneHotPhi(
    //    C /* update if this instruction happens */, Reload, LoadVal);
  }

  Mu->setIncomingValue(1, LoadVal);
}

bool GLICM::runOnLoop(VLoop *VL) {
  // Gather the sub loops in a vector to avoid invalidation
  SmallVector<VLoop *> SubLoops;
  for (auto &InstOrLoop : VL->items()) {
    if (auto *SubVL = InstOrLoop.asLoop())
      SubLoops.push_back(SubVL);
  }

  bool Changed = false;

  // Hoist things out of the sub loops first
  for (auto *SubVL : SubLoops)
    Changed |= runOnLoop(SubVL);

  if (!VL->isLoop())
    return Changed;

  // Figure out which instructions are invariant
  SmallVector<Instruction *> InvariantInsts;
  SmallVector<VLoop *> InvariantLoops;
  std::map<std::pair<Value *, Type *>, SmallVector<LoadInst *, 8>>
      ConditionallyInvariantLoads;
  unsigned NumRedundantLoads = 0;

  for (auto &InstOrLoop : VL->items()) {
    if (auto *SubVL = InstOrLoop.asLoop(); SubVL && isInvariant(SubVL, VL)) {
      InvariantLoops.push_back(SubVL);
      continue;
    }

    if (auto *I = InstOrLoop.asInstruction(); I && isInvariant(I, VL)) {
      InvariantInsts.push_back(I);
      continue;
    }

    if (auto *LI = dyn_cast_or_null<LoadInst>(InstOrLoop.asInstruction());
        LI && isInvariant(LI->getPointerOperand(), VL) &&
        !VL->getInstCond(LI) && !requiresReload(getLoadLocation(LI), VL)) {
      auto *Ptr = LI->getPointerOperand();
      ConditionallyInvariantLoads[{Ptr, LI->getType()}].push_back(LI);
      NumRedundantLoads++;
    }
  }

  if (!ConditionallyInvariantLoads.empty())
    errs() << "Num possibly invariant loads: " << NumRedundantLoads << '\n';

  // Hoist the invariant instructions to before the loop
  auto *ParentVL = VL->getParent();
  auto BeforeVL = PSSA->toIterator(VL);
  for (auto *I : InvariantInsts) {
    errs() << "!!! hoisting " << *I << '\n';
    auto *C = PSSA->concat(VL->getLoopCond(), VL->getInstCond(I));
    if (auto *PN = dyn_cast<PHINode>(I)) {
      assert(VL->isGatedPhi(PN));
      auto Conds = VL->getPhiConditions(PN);
      SmallVector<const ControlCondition *, 8> CondVec(Conds.begin(),
                                                       Conds.end());
      VL->erase(I);
      ParentVL->insert(PN, Conds, C, BeforeVL);
    } else {
      VL->erase(I);
      ParentVL->insert(I, C, BeforeVL);
    }
  }

#if 0
  for (auto *SubVL : InvariantLoops) {
    VL->erase(SubVL);
    auto *NewLoopCond = PSSA->concat(VL->getLoopCond(), SubVL->getLoopCond());
    SubVL->setLoopCond(NewLoopCond);
    ParentVL->insert(SubVL, BeforeVL);
    assert(SubVL->getParent() == ParentVL);
    errs() << "Hoisted one *loop-invariant* loop\n";
  }
#endif

  for (auto KV : ConditionallyInvariantLoads) {
    auto *LI = KV.second.front();
    hoistLoadSpeculatively(LI, VL);
    break;
  }

  return Changed | !InvariantInsts.empty() | !InvariantLoops.empty() |
         !ConditionallyInvariantLoads.empty();
}

PreservedAnalyses MyLICMPass::run(Function &F, FunctionAnalysisManager &AM) {
  auto &LI = AM.getResult<LoopAnalysis>(F);
  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
  auto &PDT = AM.getResult<PostDominatorTreeAnalysis>(F);
  auto &AA = AM.getResult<AAManager>(F);

  for (StringRef FName : FuncsToSkip)
    if (FName == F.getName())
      return PreservedAnalyses::all();

  if (!isConvertibleToPSSA(F, LI, DT))
    return PreservedAnalyses::all();

  PredicatedSSA PSSA(&F, LI, DT, PDT);
  GLICM LICM(&PSSA, AA);

  if (!LICM.runOnLoop(&PSSA.getTopLevel()))
    return PreservedAnalyses::all();

  LICM.doRAUW();

  errs() << "Hoisted something in " << F.getName() << '\n';

  lowerPSSAToLLVM(&F, PSSA);
  return PreservedAnalyses::none();
}
