; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: %opt %s -S -passes=test-vector-codegen,jump-threading -find-conditional-deps -p storeOf:and,storeOf:and4 -p and,and4 | FileCheck %s
define i32 @foo(ptr %j, ptr %i) {
; CHECK-LABEL: @foo(
; CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds i32, ptr [[I:%.*]], i64 1
; CHECK-NEXT:    [[UGLYGEP:%.*]] = getelementptr i8, ptr [[I]], i64 8
; CHECK-NEXT:    [[IDENT_CHECK:%.*]] = icmp ult ptr [[UGLYGEP]], [[J:%.*]]
; CHECK-NEXT:    [[UGLYGEP4:%.*]] = getelementptr i8, ptr [[J]], i64 4
; CHECK-NEXT:    [[UGLYGEP1:%.*]] = getelementptr i8, ptr [[I]], i64 4
; CHECK-NEXT:    [[IDENT_CHECK5:%.*]] = icmp ult ptr [[UGLYGEP4]], [[UGLYGEP1]]
; CHECK-NEXT:    [[TMP1:%.*]] = or i1 [[IDENT_CHECK]], [[IDENT_CHECK5]]
; CHECK-NEXT:    [[TMP2:%.*]] = and i1 [[TMP1]], false
; CHECK-NEXT:    br i1 [[TMP2]], label [[TMP3:%.*]], label [[TMP5:%.*]]
; CHECK:       3:
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[J]], align 4, !alias.scope !0, !noalias !3
; CHECK-NEXT:    [[TOBOOL1_NOT:%.*]] = icmp eq i32 [[TMP4]], 0
; CHECK-NEXT:    br i1 [[TOBOOL1_NOT]], label [[TMP13:%.*]], label [[TMP8:%.*]]
; CHECK:       5:
; CHECK-NEXT:    [[AND_CLONE:%.*]] = and i32 0, 0
; CHECK-NEXT:    store i32 [[AND_CLONE]], ptr [[B]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[J]], align 4
; CHECK-NEXT:    [[TOBOOL1_NOT_CLONE:%.*]] = icmp eq i32 [[TMP6]], 0
; CHECK-NEXT:    br i1 [[TOBOOL1_NOT_CLONE]], label [[TMP20:%.*]], label [[TMP7:%.*]]
; CHECK:       7:
; CHECK-NEXT:    [[CALL_CLONE:%.*]] = tail call i32 (...) null()
; CHECK-NEXT:    br label [[TMP20]]
; CHECK:       8:
; CHECK-NEXT:    [[AND_CLONE7:%.*]] = and i32 0, 0
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr null, align 4
; CHECK-NEXT:    [[AND4_CLONE:%.*]] = and i32 [[TMP9]], 0
; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <2 x i32> undef, i32 [[AND4_CLONE]], i64 0
; CHECK-NEXT:    [[TMP11:%.*]] = insertelement <2 x i32> [[TMP10]], i32 [[AND_CLONE7]], i64 1
; CHECK-NEXT:    [[TMP12:%.*]] = insertelement <2 x i1> <i1 true, i1 undef>, i1 true, i64 1
; CHECK-NEXT:    call void @llvm.masked.store.v2i32.p0(<2 x i32> [[TMP11]], ptr [[I]], i32 4, <2 x i1> [[TMP12]])
; CHECK-NEXT:    [[CALL_CLONE9:%.*]] = tail call i32 (...) null()
; CHECK-NEXT:    br label [[TMP22:%.*]]
; CHECK:       13:
; CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr null, align 4
; CHECK-NEXT:    [[TMP15:%.*]] = insertelement <2 x i32> <i32 0, i32 undef>, i32 [[TMP14]], i64 1
; CHECK-NEXT:    [[AND4_VEC:%.*]] = and <2 x i32> [[TMP15]], zeroinitializer
; CHECK-NEXT:    [[TMP16:%.*]] = extractelement <2 x i32> [[AND4_VEC]], i64 0
; CHECK-NEXT:    [[TMP17:%.*]] = extractelement <2 x i32> [[AND4_VEC]], i64 1
; CHECK-NEXT:    [[TMP18:%.*]] = insertelement <2 x i32> undef, i32 [[TMP17]], i64 0
; CHECK-NEXT:    [[TMP19:%.*]] = insertelement <2 x i32> [[TMP18]], i32 [[TMP16]], i64 1
; CHECK-NEXT:    call void @llvm.masked.store.v2i32.p0(<2 x i32> [[TMP19]], ptr [[I]], i32 4, <2 x i1> <i1 true, i1 true>)
; CHECK-NEXT:    br label [[TMP22]]
; CHECK:       20:
; CHECK-NEXT:    [[TMP21:%.*]] = load i32, ptr null, align 4
; CHECK-NEXT:    [[AND4_CLONE10:%.*]] = and i32 [[TMP21]], 0
; CHECK-NEXT:    store i32 [[AND4_CLONE10]], ptr [[I]], align 4
; CHECK-NEXT:    br label [[TMP22]]
; CHECK:       22:
; CHECK-NEXT:    ret i32 0
;
entry:
  br i1 false, label %if.end, label %if.then
if.then:
  %b = getelementptr inbounds i32, ptr %i, i64 1
  %and = and i32 0, 0
  store i32 %and, ptr %b, align 4
  br label %if.end
if.end:
  %0 = load i32, ptr %j, align 4
  %tobool1.not = icmp eq i32 %0, 0
  br i1 %tobool1.not, label %if.end3, label %if.then2
if.then2:
  %call = tail call i32 (...) null() br label %if.end3
  br label %if.end3
if.end3:
  %2 = load i32, ptr null, align 4
  %and4 = and i32 %2, 0
  store i32 %and4, ptr %i, align 4 ret i32 0
}
