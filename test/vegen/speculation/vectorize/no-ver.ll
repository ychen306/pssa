; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: %opt %s -S -passes=global-slp -do-versioning | FileCheck %s
target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.15.0"

; We can infer versionings, individually, for packs in this program, but the problem is
; collectively, the versionings are not feasible to lower.
; The point of this test is to detect this case and abort versioning.

@a = external global ptr

define i32 @d() {
; CHECK-LABEL: @d(
; CHECK-NEXT:  for.body.lr.ph:
; CHECK-NEXT:    br i1 false, label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_BODY_LR_PH_SPLIT_US:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    br label [[FOR_BODY_PREHEADER_NEW:%.*]]
; CHECK:       for.body.preheader.new:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body.lr.ph.split.us:
; CHECK-NEXT:    br label [[FOR_BODY_US:%.*]]
; CHECK:       for.body.us:
; CHECK-NEXT:    br i1 false, label [[FOR_END_LOOPEXIT21:%.*]], label [[FOR_BODY_US]]
; CHECK:       for.body:
; CHECK-NEXT:    br label [[IF_THEN:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    store float 0.000000e+00, ptr getelementptr inbounds (float, ptr @d, i64 1), align 4
; CHECK-NEXT:    store float 1.000000e+00, ptr @d, align 4
; CHECK-NEXT:    store float 2.000000e+00, ptr getelementptr inbounds (float, ptr @d, i64 2), align 4
; CHECK-NEXT:    br label [[FOR_INC:%.*]]
; CHECK:       for.inc:
; CHECK-NEXT:    br i1 false, label [[IF_ELSE_1:%.*]], label [[IF_THEN_1:%.*]]
; CHECK:       if.then.1:
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr @a, align 8
; CHECK-NEXT:    [[ARRAYIDX1_1:%.*]] = getelementptr inbounds float, ptr [[TMP0]], i64 1
; CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX1_1]], align 4
; CHECK-NEXT:    store float [[TMP1]], ptr getelementptr inbounds (float, ptr getelementptr inbounds ([3 x float], ptr @d, i64 1), i64 1), align 4
; CHECK-NEXT:    store float [[TMP1]], ptr getelementptr inbounds ([3 x float], ptr @d, i64 1), align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load float, ptr [[TMP0]], align 4
; CHECK-NEXT:    store float [[TMP2]], ptr getelementptr inbounds (float, ptr getelementptr inbounds ([3 x float], ptr @d, i64 1), i64 2), align 4
; CHECK-NEXT:    br label [[FOR_INC_1:%.*]]
; CHECK:       if.else.1:
; CHECK-NEXT:    [[CALL_1:%.*]] = tail call i32 (...) @h()
; CHECK-NEXT:    br label [[FOR_INC_1]]
; CHECK:       for.inc.1:
; CHECK-NEXT:    br label [[IF_THEN_2:%.*]]
; CHECK:       if.then.2:
; CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr @a, align 8
; CHECK-NEXT:    [[TMP4:%.*]] = load float, ptr [[TMP3]], align 4
; CHECK-NEXT:    store float [[TMP4]], ptr getelementptr inbounds (float, ptr getelementptr inbounds ([3 x float], ptr @d, i64 2), i64 1), align 4
; CHECK-NEXT:    store float [[TMP4]], ptr getelementptr inbounds ([3 x float], ptr @d, i64 2), align 4
; CHECK-NEXT:    br label [[FOR_END_LOOPEXIT:%.*]]
; CHECK:       for.end.loopexit:
; CHECK-NEXT:    br label [[FOR_END:%.*]]
; CHECK:       for.end.loopexit21:
; CHECK-NEXT:    br label [[FOR_END]]
; CHECK:       for.end:
; CHECK-NEXT:    ret i32 0
;
for.body.lr.ph:
  br i1 false, label %for.body.preheader, label %for.body.lr.ph.split.us

for.body.preheader:                               ; preds = %for.body.lr.ph
  br label %for.body.preheader.new

for.body.preheader.new:                           ; preds = %for.body.preheader
  br label %for.body

for.body.lr.ph.split.us:                          ; preds = %for.body.lr.ph
  br label %for.body.us

for.body.us:                                      ; preds = %for.body.us, %for.body.lr.ph.split.us
  br i1 false, label %for.end.loopexit21, label %for.body.us

for.body:                                         ; preds = %for.body.preheader.new
  br label %if.then

if.then:                                          ; preds = %for.body
  store float 0.000000e+00, ptr getelementptr inbounds (float, ptr @d, i64 1), align 4
  store float 1.000000e+00, ptr @d, align 4
  store float 2.000000e+00, ptr getelementptr inbounds (float, ptr @d, i64 2), align 4
  br label %for.inc

for.inc:                                          ; preds = %if.then
  br i1 false, label %if.else.1, label %if.then.1

if.then.1:                                        ; preds = %for.inc
  %0 = load ptr, ptr @a, align 8
  %arrayidx1.1 = getelementptr inbounds float, ptr %0, i64 1
  %1 = load float, ptr %arrayidx1.1, align 4
  store float %1, ptr getelementptr inbounds (float, ptr getelementptr inbounds ([3 x float], ptr @d, i64 1), i64 1), align 4
  store float %1, ptr getelementptr inbounds ([3 x float], ptr @d, i64 1), align 4
  %2 = load float, ptr %0, align 4
  store float %2, ptr getelementptr inbounds (float, ptr getelementptr inbounds ([3 x float], ptr @d, i64 1), i64 2), align 4
  br label %for.inc.1

if.else.1:                                        ; preds = %for.inc
  %call.1 = tail call i32 (...) @h()
  br label %for.inc.1

for.inc.1:                                        ; preds = %if.else.1, %if.then.1
  br label %if.then.2

if.then.2:                                        ; preds = %for.inc.1
  %3 = load ptr, ptr @a, align 8
  %4 = load float, ptr %3, align 4
  store float %4, ptr getelementptr inbounds (float, ptr getelementptr inbounds ([3 x float], ptr @d, i64 2), i64 1), align 4
  store float %4, ptr getelementptr inbounds ([3 x float], ptr @d, i64 2), align 4
  br label %for.end.loopexit

for.end.loopexit:                                 ; preds = %if.then.2
  br label %for.end

for.end.loopexit21:                               ; preds = %for.body.us
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit21, %for.end.loopexit
  ret i32 0
}

declare i32 @h(...)
